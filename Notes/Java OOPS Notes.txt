OOPS - Object Oriented Programming Structure:
--------------------------------------------
==> Java, Python, C++, JavaScript, C#, Scala, Ruby .... etc.,

OOPS Principles:
----------------
1. Inheritance
2. Polymorphism
3. Abstraction
4. Encapsulation

==> To understand the above 4 principles we should know the language constructs they are
	1. Class
	2. Object
	
CLASS:
------
==> Class is a collection of variables and method

	Syntax:
	-------
	
		class <className>{
		
			public static void test(){
				-----------
				-----------
				-----------
			}
		
			public static void main(String args[]){
				-----------
				-----------
				-----------
			}
			
			public static void qa(){
				----------
				----------
				----------
			}
		
		}
		
	Examples:
	---------
	
		class Emp{
			int empNo;
			float empSalary;
			char empSurName;
			
			void addEmployee(){
				--------
				-------
				-------
			}
			
			void deleteEmployee(){
				-------
				-------
				-------
			}
		
		}
		
		//className: --> Emp
		//methodNames: addEmployee(), deleteEmployee()
		//Variables: empNo, empSalary, empSurName
		
Object:
-------
==> Object is a instance of class

	Syntax:
	-------
		className objectReference = new Constructor();
		
	Example:
	-------
		Emp ob1 = new Emp();
		
		//ob1 --> ObjectReference --> contains the hashcode --> reference of your data
		//new Emp(); --> Object --> Contains the data
		
		new Emp();--> Anonymous Object
		
Variables:
---------
==> Variable is a container which contains some data

1. Instance Variables
2. Class Variables
3. Local Variables


Instane Variables:
------------------
==> A variable i.e., declared as a member of a class is known as Instance variable
==> Instance variables memory allocation happens whenever object is created
==> Instance variables are stored in heap are memory

Class Variables:
----------------
==> A variable i.e., declared as a static member of a class is known as class variable
==> Class variables memory allocation happens whenever class is loaded
==> class variables are stored in method area memory

Local Variables:
----------------
==> A variable i.e., defined inside a method is called as Local Variable
==> Local variable memory allocation happens whenever method is called
==> Local variables are stored in Stack area memory

Execution Priority:
-------------------
1. Class Variables
2. main method

In Java, To access the instance variable there are '2' ways
1. By using Object
2. By using ObjectReference


==> Use Object to access an instance variable if it is required only one time
==> User Object Reference to access an instance variable if it required more than one time

In Java, To access the class variable there are '4' ways
1. Directly
2. By using ClassName
3. By using Object
4. By using ObjectReference

	==> Both Object & ObjectReference are not recommended to use

==>Use className to access class variable whenever both class variable and Local variable names are same

==>Access the class Variable directly if it is present in the same class
==>use classname to access class variable if it is present in different class

==> There is only one way to access local variables i.e., directly
	1. Directly
	
==> Only one copy of class variables exists for all Objects
==> Separate copy of instance variables exists for every object

public class VarDemo {
    int x=5;//instance variable
    static int y=10;//class variable

    public static void main(String[] args) {
        VarDemo ob1 = new VarDemo();
        VarDemo ob2 = new VarDemo();

        ob1.x = ob1.x+2;
        ob1.y = ob1.y+2;

        System.out.println(ob1.x);
        System.out.println(ob1.y);
        System.out.println(ob2.x);
        System.out.println(ob2.y);
    }
}


class Emp{													class Emp{
	int empNo;													int empNo;							
	float empSalary;											static float empSalary;
}															}

															empSalary --> 4 bytes
Emp ob1 = new Emp();										Emp ob1 = new Emp();										
ob1 --> empNo, empSalary --> 8 bytes						ob1 --> empNo --> 4 bytes

Emp ob2 = new Emp();										Emp ob2 = new Emp();
ob2 --> empNo, empSalary --> 8 bytes						ob2 --> empNo --> 4 bytes

Emp ob3 = new Emp();										Emp ob3 = new Emp();
ob3 --> empNo, empSalary --> 8 bytes						ob3 --> empNo --> 4 bytes

------------------------									---------------------
------------------------									---------------------
------------------------									---------------------

Emp ob100 = new Emp();										Emp ob100 = new Emp();
ob100 --> empNo, empSalary --> 8 bytes						ob100 --> empNo --> 4 bytes

==> 800 bytes												400 + 4 bytes ==404 bytes

==> Use the Instance variable, if value is getting changed for every object
==> Use the Class variables, if value is same for all objects
==> Use the local variables, if you want to perform some action

Garbage:
--------
==> Garbage means unused objects

//Garbage Collector:
--------------------
==> It is the JVM component and it collects the garbage whenever CPU gets free time. because garbage collector priority is least priority
==> priority number is '1'

==> It is also possible to call garbage collector explicitly by using gc() method of java.lang.System class


class Demo{
	int x=5; 
	int y=10;
	public static void main(String args[]){
		Demo ob1 = new Demo();
		Demo ob2 = new Demo();
		Demo ob3 = new Demo();
		
		---------------
		---------------
		---------------
		ob1=null;
		
		--------------
		--------------
		--------------
		ob2=ob3;
	}
}

int x;//Declaration
x=10;//Assignment
int x=10;//Initialization


ARRAYS:
--------
==> An array is a collection of similar data elements
==> An array index always strts  with '0' and ends with size-1

1. Declaration:
---------------

	Syntax:
		DataType arrayRef[] = new DataType[size];
		
	Example:
		int a[] = new int[10];
		
2. Assignment:
--------------
	Syntax:
		arrayRef[index] = literal;
		
	Examples:
	---------
		a[0]=72;
		a[2]=98;
		

3. Initialization:
------------------
	Syntax:
		Datatype arrayRef[]={literal1, literal2, literal3, literal4,......};
		
	Examples:
		
		int a[] = {72,45,500,68,95};
		
Advanced For Loop/Enhanced For Loop/For Each Loop:
---------------------------------------------------
	Syntax:
		for(DataType varName: arrayRef){
			
		}
		
	Example:
	--------
		for(int b:a){
			----------
			----------
			----------
		}
	
METHODS:
--------
==> A method is a group of statements into a single logical unit

Advantages:
-----------
1. Reusability
2. Modularity

==> There are '2' types of methods in Java
1. Instance Methods
2. Class Methods


Instance Methods:
----------------
==> A method i.e., defines as a member of a class is known as Instance method

==> There are '2' ways to access the instance methods
	1. By using Object
	2. By using ObjectReference
	
Class Methods:
--------------
==> A method i.e., defined as a static member of a class is known as Class method

==> There are '4' ways to access the class variables
	1. Directly
	2. By using Class Name
	3. By using Object
	4. By using Object Reference
	
1. Method Definition --> Actual Logic will be called
2. Method Call Statement --> This is a statement to execute your block of code

==> Both Instance Method and Class Methods are divided into '4' categories
1. Method without return type and without arguments
2. Method without return type and with arguments
3. Method with return type and without arguments
4. Method with return type and with arguments

1. Method without return type and without arguments:
---------------------------------------------------

	Syntax:
	------
		void methodName(){
			-----------
			-----------
			-----------
		}
		
	Examples:
	---------
		//instance method - Method Definition
		//method without return type and without arguments
		void addEmployee(){
			-----------
			-----------
			-----------			
		}
		
		ob1.addEmployee();--> method call statement
		
2. Method without return type and with arguments:
-------------------------------------------------

	Syntax:
	-------
		void methodName(DataType var1, DataType var2, DataType var3,........ DataType varN){
			------------
			------------
			-----------
		}
		
		Examples:
		---------
		void print(int x, float y, char ch){
			-----------
			-----------
			-----------
		}
		
3. Method with return type and without arguments:
-------------------------------------------------	
	
	Syntax:
	--------
		DataType methodName(){
			-----------
			-----------
			-----------
			
			return value;
			
		}

	
4. Method with return type and with arguments:
----------------------------------------------
	Syntax:
		DataType methodName(DataType var1, DataType var2, DataType var3,........ DataType varN){
			-----------
			-----------
			-----------
			
			return value;
			
		}
==>In Method definition, if there is a return value, then that method must return it, otherwise compilation Error will come
==>If Method definition is returning some value, method call statement may take the value or not. there will be no compilation Error even if it don't take
==> However method is defined with some arguments, same way we must pass the number of arguments in method call statement.

this keyword:
-------------
==> this keyword is called as objectReference, because it refers the object
==>It always refers the current object and it is implicitly present in Instance method


public class Demo {
    int x=5;

    public static void main(String[] args) {
        Demo ob1 = new Demo();
        ob1.show();
    }

    void show(){
        System.out.println(x);
    }
}

public class Demo {
    int x=5;

    public static void main(String[] args) {
        Demo ob1 = new Demo();
        Demo ob2 = new Demo();
        ob1.x = ob1.x+2;
        ob1.show();
        ob2.show();
    }

    void show(){
        System.out.println(this.x);
    }
}

=>this keyword explicitly required to access an instance variable whenever both instance variable name and local variable names are same
==>Static method doesn't refer 'this' keyword in anyway (explicitly and Implicitly)

CONSTRUCTORS:
-------------
==> Constructor is a special method which has the same name as a class name and which has no retun type
==> constructor is called automatically whenever an object is created
==> Constructors are used to initialise the instance variables

==> Constructors are '2' types
	1. Default constructor [without arguments]
	2. Parameterized constructor [with arguments]
	
1. 
class Demo{
	Demo(){//valid constructor
		-------
		-------
		-------
	}
}

2. 
class Demo{
	demo(){//error, Not valid constructor
		-------
		-------
		-------
	}
}

3. 
class Demo{
	void Demo(){//Valid method, but it is not following java standards
		-------
		-------
		-------
	}
}
 
4. 
class Demo{
	void demo(){//valid method
		-------
		-------
		-------
	}
}

==> this() --> It calls default constructor of current class
==> this(DataType1 var1, DataType2 var2,.....) --> It calls Parameterized constructor of a current class

Note:
==> this(); or this(arg1, arg2, arg3,.....argN); --> must be a first statement in the constructor

==> Constructors are used to initialise the instance variables

==> Whenever object is created, memory allocation happening to instance variables
==> Constructor will be automatically whenever object is created


int x=10;//initialization

int x;//definition
x=10;//Assignment

Difference b/w Methods and Constructors:
-----------------------------------------
		Constructors											Methods
1. constructor is not having any return type					1. method must have return type [without return type means void should be written]
2. Constructor is a special method, which has same name			2. Methods is a group of statements into a sing - Any name can be given
as the className
3. Constructors are automatically wheneverobject is created		3. Methods must be called explicitly after creating the object
4. Constructors are used to initialize the instance variables	4. Methods are used to perform some task
5. Constructor is called only one time for one object			5. Methods can be called any number of time for one object

Note:
==> If the class does not contain any constructor, then only system will provides one default constructor implicitly

1. 
class Demo{//Valid
	//Demo(){} --> System provided default constructor implicitly
	public static void main(String args[]){
		Demo ob1 = new Demo();
	}
}

2. 
class Demo{
	//Demo(){} --> System provided default constructor implicitly
	public static void main(String args[]){
		Demo ob1 = new Demo(5); // Error will come as there is no Parameterized constructor is written
	}
	
}

3. 
class Demo{//Valid

	Demo(int x){
		-------
		-------
		-------
	}
	public static void main(String args[]){
		Demo ob1 = new Demo(5);
	}
}

4. 
class Demo{
	Demo(int x){
		-------
		-------
		-------
	}
	public static void main(String args[]){
		Demo ob1 = new Demo();
	}
}
OOPS Principles:
----------------
1. Inheritance
2. Polymorphism
3. Encapsulation
4. Abstraction

Inheritance:
------------
==> Creating a new class from an existing class is called as Inheritance
==> Newly created class is called as 'Sub Class' (or) 'Child Class'
==> Existing class is called as 'Super Class' (or) 'Parent Class'

class Student{		//Existing Class --> Super Class

	int rollNo;
	String name;
	char gender;
	long landlineNo;
	
	--------------
	--------------
	--------------
}

class Student1 extends Student{ //New Class - Sub Class
	long mobileNo;
	String emailId;
	
	--------------
	--------------
	--------------
}
==> 'extends' is a keyword to make a relationship between two different classes

==> Whenever object is created for super class, memory allocation happens for only super class members
==> Whenever object is created for sub class, memory allocation happens for both super class members and sub class members

Types of Inheritance:
---------------------
1. Single Inheritance
2. Multiple Inheritance
3. Multilevel Inheritance
4. Hierarchial Inheritance
5. Multipath Inheritance
6. Hybrid Inheritance

Single Inheritance:
-------------------
==>Derivation of a class from only one super class is known as Single Inheritance
		A//Super class
		|
		B//sub class
		
Multiple Inheritance:
----------------------
==>Derivation of a class from more than one super class is known as Multiple Inheritance

		A           B
		|			|
		-------------
			|
			C
			
Multilevel Inheritance:
-----------------------
==> Derivation a class from Sub class is called as Multilevel Inheritance
		A
		|
		B
		|
		C

Hierarchial Inheritance:
------------------------
==> Derivation of several classes from only super class is called as Hierarchial Inheritance
			A//Super class
			|
		---------
		|	|	|
		B	C	D//sub classes
		
Multipath Inheritance:
----------------------
==> Derivation a class from more than one sub class and these subclasses are derived from same super class is called as Multipath Inheritance
						A
						|
					----------
					|		|
					B		C
					---------
						|
						D
Hybrid Inheritance:
-------------------
==> Derivation of a class involving more than one form of Inheritance is called as Hybrid Inheritance
			A
			|
			B	C
			|	|
			-----
			  |
			  D
	Note: Multipath Inheritance can also example of Hybrid Inheritance
	
Note: Java doesn't support Multiple Inheritance, Multipath Inheritance and Hybrid Inheritance

		A show()          B show()
		|		          |
		-------------------
			|
			C 
			
			C ob1 = new C();
			ob1.show();
==>Java doesn't support multipath Inheritance and Hybrid Inheritance because both types contains multiple Inheritance